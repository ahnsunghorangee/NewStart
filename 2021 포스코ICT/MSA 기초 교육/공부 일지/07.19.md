# Stream

- 스트림은 '데이터의 흐름'
- 배열과 컬렉션을 함수형으로 처리 가능
- 병렬처리(multi-threading)가 가능
  - 하나의 작업을 둘 이상의 작업으로 잘게 나눠서 동시에 진행하는 것
  - 쓰레드를 이용해 많은 요소들을 빠르게 처리할 수 있다.



- Stream 절차

### 1. 생성하기

- 스트림 인스턴스 생성

```java
// 배열 스트림
String[] arr = new String[]{"a", "b", "c"};
Stream<String> stream = Arrays.stream(arr);
Stream<String> streamOfArrayPart =
        Arrays.stream(arr, 1, 3); // 1~2 요소 [b, c]

System.out.println(Arrays.toString(arr));
stream.forEach(System.out::println);
streamOfArrayPart.forEach(System.out::println);

// 컬렉션 스트림
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> stream2 = list.stream();
Stream<String> parallelStream = list.parallelStream(); // 병렬 처리 스트림

System.out.println(list);
stream2.forEach(System.out::println);
parallelStream.forEach(System.out::println);

// Stream.builder()
// 스트림에 직접적으로 원하는 값을 넣을 수 있다.
Stream<String> builderStream =
        Stream.<String>builder()
                .add("Eric").add("Elena").add("Java")
                .build(); // [Eric, Elena, Java]
builderStream.forEach(System.out::println);

// Stream.generate()
// 람다로 값을 넣을 수 있다. 단, 크기가 무한이기 때문에 제한해야한다.
Stream<String> generatedStream =
        Stream.generate(() -> "gen").limit(5); // [el, el, el, el, el]
generatedStream.forEach(System.out::println);

// Stream.concat() 메서드를 이용해 두 개의 스트림을 연결
Stream<String> stream3 = Stream.of("Java", "Scala", "Groovy");
Stream<String> stream4 = Stream.of("Python", "Go", "Swift");
Stream<String> concat = Stream.concat(stream3, stream4); // [Java, Scala, Groovy, Python, Go, Swift]
concat.forEach(System.out::println);
```

### 2. 가공하기

- 필터링(filtering) 및 맵핑(mapping) 등 원하는 결과를 만들어가는 중간 작업

```java
System.out.println("가공하기");
List<String> names = Arrays.asList("Eric", "Elena", "Java");

// filter()
// 스트림 내 요소들을 하나씩 평가해서 걸러내는 작업
Stream<String> stream5 =
        names.stream()
                .filter(name -> name.contains("a")); // [Elena, Java]
stream5.forEach(System.out::println);

// Mapping()
// 스트림 내 요소들을 하나씩 특정값으로 변환해준다.
Stream<String> stream6 =
        names.stream()
                .map(String::toUpperCase); // [ERIC, ELENA, JAVA]
stream6.forEach(System.out::println);

// Sorting()
IntStream.of(14, 11, 20, 39, 23)
        .sorted()
        .boxed()
        .collect(Collectors.toList()); // [11, 14, 20, 23, 39]

// 역순 정렬
List<String> lang =
        Arrays.asList("Java", "Scala", "Groovy", "Python", "Go", "Swift");

lang.stream()
        .sorted()
        .collect(Collectors.toList()); // [Go, Groovy, Java, Python, Scala, Swift]
lang.stream()
        .sorted(Comparator.reverseOrder())
        .collect(Collectors.toList()); // [Swift, Scala, Python, Java, Groovy, Go]
```

### 3. 결과 만들기

- 최종적으로 결과를 만들어내는 작업

```java
long count = IntStream.of(1, 3, 5, 7, 9).count();
long sum = LongStream.of(1, 3, 5, 7, 9).sum();
System.out.println(count+" " +sum);

List<Product> productList =
        Arrays.asList(new Product(23, "potatoes"),
                new Product(14, "orange"),
                new Product(13, "lemon"),
                new Product(23, "bread"),
                new Product(13, "sugar"));

// Collectors.toList()
List<String> collectorCollection =
        productList.stream()
                .map(Product::getName)
                .collect(Collectors.toList()); // [potatoes, orange, lemon, bread, sugar]


// Collectors.joining()
String listToString =
        productList.stream()
                .map(Product::getName)
                .collect(Collectors.joining()); // potatoesorangelemonbreadsugar
```





# Optional

### 1. Optional 객체 생성

```java
// public static <T> Optional<T> of(T value);
// value가 null인 경우 NPE를 던진다. 반드시 값이 있어야 하는 객체인 경우 사용한다.
Optional<String> opt = Optional.of("result");


// public static <T> Optional<T> ofNullable(T value);
// value가 null인 경우 비어있는 Optional을 반환한다. 값이 null일수도 있을때 사용한다.
Optional<String> opt2 = Optional.ofNullable(null);


// public static<T> Optional<T> empty();
// 비어있는 Optional 객체를 생성한다.
Optional<String> opt3 = Optional.empty();
```

### 2. Optional 중간 처리

```java
// public Optional<T> filter(Predicate<? super T> predicate);
// predicate 값이 참이면 해당 필터를 통과 / 거짓이면 통과 x
Optional.of("true").filter(val -> val.equals("true")).orElse("No Data");
Optional.of("false").filter(val -> val.equals("true")).orElse("No Data");


// public<U> Optional<U> map(Function<? super T, ? extends U> mapper);
// mapper 함수를 통해 입력값을 다른 값으로 변환하는 메서드
Integer test = Optional.of("1").map(Integer::valueOf).orElseThrow(NoSuchElementException::new); // string to integer


// public<U> Optional<U> flatMap(Function<? super T, Optional<U>> mapper);
// mapper 함수를 통해 입력값을 다른 값으로 변환하는 메서드
// map()과 다른 점은 제네릭으로 Optional(U)를 정의
String result = Optional.of("result")
        .flatMap((val) -> Optional.of("good"))
        .get();
System.out.println(result); // print 'good'
```

### 3. Optional 종단 처리

```java
// public void ifPresent(Consumer<? super T> consumer);
// 최종적으로 연산을 끝낸 후 값이 비어있지 않다면 입력값으로 주어진다.
Optional.of("test").ifPresent((value) -> { // 수행 o
    // something to do
});
Optional.ofNullable(null).ifPresent((value) -> { // 수행 x
    // nothing to do
});


// public boolean isPresent();
// 최종적으로 연산을 끝낸 후 객체가 존재하는지 여부를 판별한다.
Optional.ofNullable("test").isPresent(); // true
Optional.ofNullable("test").filter((val) -> "result".equals(val)).isPresent(); // false


// public T get();
// 최종적으로 연산을 끝낸 후 객체를 꺼낸다. 이때 비어있는 옵셔널 객체였다면 예외 발생
Optional.of("test").get(); // 'test'
Optional.ofNullable(null).get(); // NoSuchElementException!


// public T orElse(T other);
// 최종적으로 연산을 끝낸 후에도 Optional 객체가 비어있다면 기본값으로 제공할 객체를 지정한다.
String result2 = (String) Optional.ofNullable(null).orElse("default");
System.out.println(result2); // print 'default'
```

