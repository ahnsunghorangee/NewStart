# 타입스크립트 클래스

자바스크립트는 프로토타입 기반을 이용해 상속을 구현한다. ES6에 존재하는 class 키워드를 이용해 구현할 수 있다.



#### 클래스 키워드

```tsx
// TS
class Button {
    constructor() {
      // ...
    }
}
```



#### 생성자

다른 언어와 마찬가지로 생성자를 통해 멤버들을 초기화시켜준다. 타입스크립트도 동일한데 다만, 사전에 등록되지 않은 프로퍼티를 초기화하려면 에러가 난다.

```tsx
// TS
class Button {
    constructor(name: string) {
        this.name = name; // Error!
        // TS2339: Property 'name' does not exist on type 'Button'.
    }
}
```

위와 같이 하면 에러 발생!



```tsx
// TS
class Button {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
}
```



#### 상속

```tsx
// TS
class Input {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
    inputName() {
        console.log(`input name is ${ this.name }`);
    }
}
class Button extends Input {
    constructor(name: string) {
        super(name);
    }
}
const button = new Button('click me');
button.inputName(); // input name is click me
```

현재 상속 계층은 Button이 Input을 상속받고 있다.



하위 클래스에서 constructor를 정의하고 싶다면 반드시 상위 클래스의 constructor를 호출해야만 한다.

super() 사용!



#### 오버라이드

> 오버라이드란? 상위 클래스에서 정의한 메서드를 자식 클래스에서 재정의 하는 것

```tsx
class Input {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
    inputName() {
        console.log(`input name is ${ this.name }`);
    }
}
class Button extends Input {
    constructor(name: string) {
        super(name);
    }
    inputName() {
        console.log(`button name is ${ this.name }`);
    }
}
const button = new Button('click me');
button.inputName(); // button name is click me
```

@Override 안쓴다.



> 오버로딩은 지원하지 않는다. 대신 any를 이용하면 오버로딩 비슷하게 구현 가능하다.



#### 접근제어자

- public: 디폴트 값, 어디에서나 접근 가능
- protected: 상속받은 하위 클래스만 접근 가능
- private: 선언한 클래스 내에서만 접근 가능



※ protected

```tsx
class Input {
    protected name: string;
    constructor(name: string) {
        this.name = name;
    }
    protected inputName() {
        console.log(`input name is ${ this.name }`);
    }
}
const input = new Input('input');
// console.log(input.inputName()); Error!
// TS2445: Property 'inputName' is protected and only accessible within class 'Input' and its subclasses.
```

public인 constructor()를 통해 인스턴스를 생성했지만, protected 접근제어자가 붙은 inputName()은 외부에서 호출할 수 없다.



```tsx
// TS
class Input {
    protected name: string;
    protected constructor(name: string) {
        this.name = name;
    }
    protected inputName() {
        console.log(`input name is ${ this.name }`);
    }
}
class Button extends Input {
    constructor(name: string) {
        super(name);
    }
    inputName() {
        console.log(`button name is ${ this.name }`);
    }
}
const button: Input = new Input('button'); // Error!
// TS2674: Constructor of class 'Input' is protected and only accessible within the class declaration.
```

constructor()에 protected가 붙는다면 해당 클래스는 바로 인스턴스화 될 수 없다. 



```tsx
// TS
const button: Input = new Button('button');
```

**상속받은 하위 클래스에서 super를 이용해 호출할 수 있다.**



※ readonly

```tsx
// TS
class Person {
    readonly name: string;
    constructor(name: string) {
        this.name = name;
    }
}
const person = new Person('heecheolman');
// person.name = 'kimheecheol'; Error!
// TS2540: Cannot assign to 'name' because it is a read-only property.
```

읽기전용 프로퍼티로 만든다. readonly를 붙이면 constant(상수)로 인식되며 생성자에서 한 번 결정된 후에는 변경할 수 없다.



#### 매개변수 프로퍼티

선언과 할당을 동시에 할 수 있다.

```tsx
// TS
class Person {
    constructor(readonly name: string) {}
    greet() {
        console.log(`my name is ${ this.name }`);
    }
}
const person = new Person('heecheolman');
person.greet(); // my name is heecheolman
```



#### static

지금까지의 변수나 메서드들을 살펴보면 인스턴스화 -> 호출 형식이다.



그렇지만 인스턴스화가 필요하지 않는 경우도 있다. **바뀌지 않고 공통적으로 사용될 값 혹은 메서드**인 경우

```tsx
// TS
interface Point {
    x: number;
    y: number;
}
class Grid {
    static origin: Point = {
        x: 0,
        y: 0,
    };
    scale: number;
    constructor(scale: number) {
        this.scale = scale;
    }
    calcDistanceFromOrigin(point: Point): number {
        let dx = point.x - Grid.origin.x;
        let dy = point.y - Grid.origin.y;
        return Math.sqrt((dx * dx) + (dy * dy) / this.scale);
    }
}
let grid1 = new Grid(1.0); // 1x scale
let grid2 = new Grid(5.0); // 2x scale
const point: Point = {
    x: 10,
    y: 10,
};
console.log(grid1.calcDistanceFromOrigin(point)); // 14.142135623730951
console.log(grid2.calcDistanceFromOrigin(point)); // 10.954451150103322
```

