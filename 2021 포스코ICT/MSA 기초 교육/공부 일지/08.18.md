# 타입스크립트 추상 클래스

#### 추상클래스의 특징

- abstract 키워드를 클래스 앞에 추가한다.
- 추상클래스 내의 메서드에 abstract 키워드를 붙이면 파생클래스에서 반드시 구현해야한다.
- 추상클래스는 new를 통해 인스턴스화 할 수 없다.



#### 인터페이스와 다른점?

- 인터페이스와 달리 추상 클래스의 멤버에 대한 구현 세부 정보를 포함할 수 있다.

```tsx
// TS
abstract class Job {
    readonly nickname: string;
    constructor(nickname: string) {
        this.nickname = nickname;
    }
    greet(): void {
        console.log(`My nickname is ${ this.nickname }`);
    }
    abstract attack(): void;
}
class Warrior extends Job {
    attack() {
        console.log('검을 사용해 공격!');
    }
}
class Magician extends Job {
    attack() {
        console.log('마법을 사용해 공격!');
    }
}
// const job: Job = new Job('what'); Error!
// TS2511: Cannot create an instance of an abstract class.
const warrior: Job = new Warrior('heecheolman');
const magician: Job = new Magician('heecheol');
warrior.greet(); // My nickname is heecheolman
magician.greet(); // My nickname is heecheol
warrior.attack(); // 검을 사용해 공격!
magician.attack(); // 마법을 사용해 공격!
```

첫번째 에러는 추상클래스를 인스턴스화 하려하여 생긴 에러이다.



# 타입스크립트 함수

#### 함수 작성

타입스크립트에서 함수는 ES6에서 매개변수 타입과 return 타입만 추가하면 된다.

```tsx
// ES6
function add(num1, num2) {
    return num1 + num2;
}
// TS
function add(num1: number, num2: number): number {
    return num1 + num2;
}
```

이렇게도 쓸 수 있다.

```tsx
// TS
const add = (num1: number, num2: number): number => num1 + num2;
```



#### Default Parameter

매개변수에 값을 전달하지 않을 시 나타나는 undefined 대신 기본값으로 초기화해준다.

```tsx
// TS
function add(num1: number = 0, num2: number = 0): number {
    return num1 + num2;
}
```



#### Optional Parameter

인터페이스에서의 선택적 프로퍼티처럼 매개변수의 값이 있을수도 있고 없을 수도 있는 상황에서 사용한다.

 ?를 이용하여 선택적인 매개변수로 지정할 수 있다.

```tsx
// TS
function greet(lastName: string, firstName?: string): string {
    let message = `my name is ${ lastName }`;
    if(firstName) {
        message += firstName;
    }
    return message;
}
console.log(greet('heecheol', 'kim')); // my name is heecheolkim
console.log(greet('heecheol')); // my name is heecheol
```



주의할 점으로, 선택적 매개변수는 오른쪽 정렬로 등록해줘야한다.

```tsx
// TS
function greet(lastName: string, firstName?: string): string { ... } // (O)
function greet(firstName?: string, lastName: string): string { ... } // (X)
```



#### Rest Parameter

ES6에서의 ...(스프레드 연산자)를 통해 타입스크립트에서도 동일하게 사용할 수 있다. 스프레드 연산자는 배열이므로 타입을 지정해 줄 때 배열임을 명시해준다.

```tsx
// TS
function nameListBuilder(...nameList: string[]) {
    // ...
}
```



#### Union Type

함수의 매개변수나 리턴타입을 정할 때 2가지 이상의 타입일 수 있다. 이럴 때 유니온 타입을 사용한다.

```tsx
// TS
function numberOrString(data: number | string) {
    if(typeof data == 'number') {
        // ...
    } else if(typeof data == 'string') {
        // ...
    }
}
```



#### Overloading

자바스크립트는 원래 오버로딩이 구현이 안되어있다. 타입스크립트를 쓴다고 구현이 되는 것은 아니지만 비슷하게 구현할 수 있다.

```tsx
// TS
function greetBuilder(firstName: string, age?: number): void;
function greetBuilder(firstName: string, age: string): void;
function greetBuilder(firstName: string, age: number | string): any {
    let message = `Hi My Name is ${ firstName }`;
    if(typeof age == 'number') {
        message += `, ${ age + 1 } years old at next year`;
    } else if(typeof age == 'string') {
        message += `, ${ age } years old.`;
    }
    return message;
}
console.log(greetBuilder('kim')); // Hi My Name is kim
console.log(greetBuilder('kim', 24)); // Hi My Name is kim, 25 years old at next year
console.log(greetBuilder('kim', '24')); // Hi My Name is kim, 24 years old.
```

greetBuilder라는 함수 시그니쳐가 3개 이지만, 구현은 마지막에 한다. 구현에서 각 타입에 맞게 분기를 반환하는 것을 볼 수 있다.