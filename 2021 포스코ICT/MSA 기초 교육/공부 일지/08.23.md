# JS/TS for문

#### 1. forEach

Map, Set에서의 forEach문은 Array의 forEach와 조금 다르다.



Array의 forEach가 받은 콜백함수의 인수는 순서대로 값, 인덱스 배열순이다.



Map, Set에서의 forEach가 받는 콜백함수의 인수는 값, 키, 오브젝트로 들어온다.

```tsx
// JavaScript
const map = new Map();
const set = new Set();
 
// TypeScript
const map = new Map<string, string>();
const set = new Set<string>();
 
map.set('name', 'Mommoo');
map.set('age' , 'secret');
 
set.add('Mommoo');
set.add('secret');
 
map.forEach((value, key, mapObject) => console.log(key +' , ' +value));
// name , Mommoo
// age , secret
 
set.forEach((value1, value2, setObject) => console.log(value1 +' , '+ value2));
// Mommoo , Mommoo
// secret , secret
```



#### 2. for..of

forEach문은 순회 중간에 continue, break, return과 같은 기능을 못 쓰지만 for..of문에서는 가능하다.



Map의 for..of로 호출되는 값은 키와 밸류가 들억 있는 배열이다.



Set의 for..of로 호출되는 값은 벨류이다.



#### 2-1) JavaScript

```js
const map = new Map();
const set = new Set();
 
map.set('name', 'Mommoo');
map.set('age' , 'secret');
 
set.add('Mommoo');
set.add('secret');
 
for ( let item of map ) {
  console.log(item[0] +' , '+ item[1]);
}
// name , Mommoo
// age , secret
 
for ( let item of set ) {
  console.log(item);
}
// Mommoo
// secret
```



#### 2-2) TypeScript

TypeScript는 Iterable 속성 때문에 for..of문이 컴파일 되지 않는다.



위의 JS와 같이 사용하고 싶다면 컴파일러 속성인 --downlevelIteration을 켜주어야한다.



만약 키지 않을 경우, 대안으로 ES6 Array API인 Array.from API를 사용해서 구현해야한다.

```tsx
const map = new Map<string, string>();
const set = new Set<string>();
 
map.set('name', 'Mommoo');
map.set('age' , 'secret');
 
set.add('Mommoo');
set.add('secret');
 
for ( let item of Array.from(map) ) {
  console.log(item[0] +' , '+ item[1]);
}
// name , Mommoo
// age , secret
 
for ( let item of Array.from(set) ) {
  console.log(item);
}
// Mommoo
// secret
```

