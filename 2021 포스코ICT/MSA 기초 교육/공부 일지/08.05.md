# JSON vs GSON

## Json이란

#### 문법

- 객체는 중괄호{}
- 배열은 대괄호[]
- 각 속성은 key와 value 쌍, 콜론:으로 구분
- 속성이 여러 개인 경우 쉼표,로 구분

#### 장점

1. 가독성
   - 객체의 구조를 파악하기 쉬운 형태
2. 가볍다
   - json 이전 xml은 매우 무겁다는 단점... 왜? 데이터마다 테그를 이용해 설명을 부여해서.
   - json은 태그를 사용하지 않고 name:value 쌍으로 데이터를 표현
3. 플랫폼 독립적
   - JSON 형식만 지킨다면 어느 시스템간이든 데이터 교환이 가능



``` java
package test;

import org.json.JSONException;
import org.json.JSONObject;

public class JsonTest {

    public static void main(String[] args) {
        String jsonString = "{'age':20, 'name':'sunho', 'student':{'age':22,'name':'ahn'}}";

        try{
            // JSONObject: json형식의 매개변수를 json 객체로 만들어준다.
            JSONObject json = new JSONObject(jsonString);
            System.out.println(json);

            // JSON 객체의 get("key") 메서드로 value만을 가져올 수 있다.
            System.out.println("age: "+json.getInt("age"));

            // json안의 객체를 getJSONObject("key") 메서드로 가져올 수 있다.
            System.out.println("student: " + json.getJSONObject("student"));

            // JSON Object 생성 -> key-value 형식
            JSONObject object = new JSONObject();
            object.put("gener", "F");
            object.put("animal",123);
            System.out.println("json 객체 생성: " + object);
        } catch(JSONException e){
            e.printStackTrace();
        }
    }
}
```

결과

```
{"student":{"name":"ahn","age":22},"name":"sunho","age":20}
age: 20
student: {"name":"ahn","age":22}
json 객체 생성: {"gener":"F","animal":123}
```





## Gson이란

- json 구조를 띄는 직렬화된 데이터를 JAVA의 객체로 역직렬화, 직렬화 해주는 자바 라이브러리

- 즉, JSON Object -> JAVA Object 또는 반대의 행위를 돕는 라이브러리

``` java
package test;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import test.entity.Student;

public class GsonTest {

    public static void main(String[] args) {
        // Test1. JSON -> GSON(Java Object)
        String jsonString="{'age':20, 'name':'Sungho'}";
        // Gson 객체 생성
        Gson gson1 = new GsonBuilder().create();
        // JSON -> GSON(Java Object)
        Student student1 = gson1.fromJson(jsonString, Student.class);
        student1.getInfo();

        // Test2. GSON(Java Object) -> JSON
        Student student2 = new Student(20,"ASH");
        // Gson 객체 생성
        Gson gson2 = new GsonBuilder().create();
        // GSON(Java Object) -> JSON
        String json = gson1.toJson(student2);
        System.out.println(json);
    }
}

```

결과

```
이름은: Sungho이고, 나이는 20입니다.
{"age":20,"name":"ASH"}
```



#### Gson 장점?

```java
package test.entity;

public class Student {

    private int age;
    private String name;

    public Student(int age, String name){
        this.age = age;
        this.name = name;
    }

    public void getInfo(){
        System.out.println("이름은: "+this.name+"이고, 나이는 "+this.age+"입니다.");
    }
}

```

```
String jsonString="{'age':20, 'name':'Sungho'}"; -> 이름은: Sungho이고, 나이는 20입니다.
String jsonString="{'name':'Sungho'}"; -> 이름은: Sungho이고, 나이는 0입니다.
String jsonString="{'age':20, 'name':'Sungho','gender':'F'}"; -> 이름은: Sungho이고, 나이는 20입니다.
```

있으면 있는데로 없으면 없는데로 사용, 없다고 오류 안나고 많다고 오류 안 난다.



# POJO(Plain Old Java Object)

- 특별한 **제한에 종속되지 않고**, 클래스 패스(class path)를 필요로 하지 않는 일반적인 Java Object



#### 그래서 POJO에서는 다음과 같은 것을 해선 안된다.

1. 미리 지정된 클래스를 extends 하는 것
2. 미리 정의된 인터페이스를 implement 하는 것
3. 미리 정의된 Annotation을 포함하는 것



# 커넥션 풀(DBCP)란?

- 웹 컨테이너(WAS)가 실행되면서 DB와 미리 connection(연결)을 해놓은 객체들을 pool에 저장해두었다가
- 클라이언트 요청이 오면 connection을 빌려주고
- 처리가 끝나면 다시 connection을 반납받아 pool에 저장하는 방식

<center>
    <img src="https://linked2ev.github.io/assets/img/devlog/201908/cp-s1.png"/>
</center>

#### 커넥션 풀을 사용하는 이유

```java
Connection conn = null;
PreparedStatement  pstmt = null;
ResultSet rs = null;

try {
    sql = "SELECT * FROM T_BOARD"

    // 1. 드라이버 연결 DB 커넥션 객체를 얻음
    connection = DriverManager.getConnection(DBURL, DBUSER, DBPASSWORD);

    // 2. 쿼리 수행을 위한 PreparedStatement 객체 생성
    pstmt = conn.createStatement();

    // 3. executeQuery: 쿼리 실행 후
    // ResultSet: DB 레코드 ResultSet에 객체에 담김
    rs = pstmt.executeQuery(sql);
    } catch (Exception e) {
    } finally {
        conn.close();
        pstmt.close();
        rs.close();
    }
}
```

DB에 요청을 보낼 때, 매번 JDBC 드라이버를 로드하고 커넥션 객체를 받아와야한다. -> 비효율적

그래서 DBCP(DataBase Connection Pool)를 사용

#### DBCP 역할

DB와 커넥션을 맺고 있는 객체를 관리하는 역할

#### DBCP 특징

- WAS가 실행되면서 connection 객체를 미리 pool에 생성해둔다.
- HTTP 요청에 따라 pool에서 connection객체를 가져다 쓰고 반환한다.
- 이런 방식으로 물리적인 데이터베이스 connection 부하를 줄이고 연결 관리한다.
- pool에 미리 connection이 생성되어 있기 때문에 connection을 생성하는데 드는 요청 마다 연결 시간이 소비되지 않는다.
- 커넥션을 계속해서 재사용하기 때문에 생성되는 커넥션 수를 제한적으로 설정한다.

#### 동시 접속자가 많을 경우

- 사용할 connection이 반환될 때까지 번호순서대로 대기 상태
