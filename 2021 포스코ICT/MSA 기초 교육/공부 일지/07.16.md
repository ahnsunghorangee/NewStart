# 07.16 (금)

# :star: 1. 싱글턴 패턴(Singleton Pattern)

- 싱글턴 패턴이란?

  - 인스턴스가 오직 1개만 생성되야 하는 경우 사용되는 패턴

    Node n; // 객체

    n = new Node(); // n은 Node 클래스의 '인스턴스(객체를 메모리에 할당)'

  - 하나의 인스턴스를 메모리에 등록해서 여러 스레드가 동시에 해당 인스턴스를 공유하여 사용하여, 요청이 많은 곳에서 효율이 높다.

  - 주의! 동시성(Concurrency)



# 자바의 싱글턴 패턴

- 싱글턴 패턴의 공통적인 특징
  - private constructor를 가지는 것
  - static method를 사용한다는 점



## 싱글턴 패턴 구현 방식

### 1) Eager Initialization(이른 초기화, Thread-safe)

```java
public class SingletonPattern {
    // Eager Initialization
    private static SingletonPattern uniqueInstance = new SingletonPattern();

    private SingletonPattern() {}

    public static SingletonPattern getInstance(){
        return uniqueInstance;
    }
}
```

- static 키워드 특징을 이용해, 클래스 로더 초기화 시점에서 정적 바인딩(static binding)을 통해 해당 인스턴스를 메모리에 등록해서 사용한다.
- 클래스 로더에 의해 클래스가 최초로 로딩 될 때 객체가 생성되기 때문에 Thread-safe하다.



### 2) Lazy Initialization with synchronized(동기화 블럭, Thread-safe)

- 메서드에 동기화 블럭을 지정해서 Thread-safe를 보장한다.
- 컴파일 시점에 인스턴스를 생성하는 것이 아니라, 인스턴스가 필요한 시점에 요청하여 동적 바인딩(dynamic binding) (런타임 시, 성격이 결정됨)을 통해 인스턴스를 생성하는 방식이다.

```java
public class SingletonPattern {
    private static SingletonPattern uniqueInstance;

    private SingletonPattern() {}

    // Lazy Initialization
    public static synchronized SingletonPattern getInstance(){
        if(uniqueInstance == null){
            uniqueInstance = new SingletonPattern();
        }
        return uniqueInstance;
    }
}
```

- 단점
  - 인스턴스가 생성되었든, 안되었든 무조건 동기화 블록을 거치게 된다.
  - synchronized  키워드를 사용하면 성능이 100배 가량 떨어진다.



### 3) Lazy Initialization. Double Checking Locking(DCL, Thread-safe)

- 동기화 블럭 방식을 개선한 방식이다.
- 인스턴스가 생성되지 않은 경우에만 동기화 블럭이 실행되게끔 구현한 방식이다.

``` java
public class SingletonPattern {
    private volatile static SingletonPattern uniqueInstance;

    private SingletonPattern() {}

    // Lazy Initialization. DCL
    public SingletonPattern getInstance() {
        if (uniqueInstance == null) {
            synchronized (SingletonPattern.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new SingletonPattern();
                }
            }
        }

        return uniqueInstance;
    }
}
```

- volatile 키워드는 멀티 쓰레딩을 쓰더라도 uniqueInstance 변수가 Singleton 인스턴스로 초기화 되는 과정이 올바르게 진행되조록 할 수 있다.



- **volatile 키워드**가 필요한 이유?
  - volatile 변수를 사용하지 않는 멀티스레드 어플리케이션
    - 작업(Task)을 수행하는 동안 성능 향상을 위해 Main Memory에서 읽은 변수 값을 CPU Cache에 저장
    - 만약 멀티스레드 환경에서 스레드가 변수값을 읽어올 때 각각의 CPU Cache에 저장된 값이 다르기 때문에 변수값 불일치 문제가 발생
  - volatile 변수 사용
    - Main Memory에 값을 저장하고 읽어오기 때문에(read and write) 변수값 불일치 문제가 생기지 않는다.



### 4) Lazy Initialization. Enum(열거 상수 클래스, Thread-safe)

- Enum 인스턴스의 생성은 기본적으로 Thread-safe하다. 따라서 스레드 관련 코드가 필요없다.
- 하지만 Enum 내의 다른 메서드가 있는 경우 해당 메서드가 Thread-safe한지는 개발자가 책임져야 한다.

``` java
public enum Singleton {
    INSTANCE; 
}
```



### 5) Lazy Initialization. LazyHolder(게으른 홀더, Thread-safe)

- 가장 많이 사용되는 싱들턴 구현 방식
- volitate나 synchronized 키워드 없이도 동시성 문제를 해결 가능

``` java
public class Singleton {

    private Singleton() {}

    /**
     * static member class
     * 내부클래스에서 static변수를 선언해야하는 경우 static 내부 클래스를 선언해야만 한다.
     * static 멤버, 특히 static 메서드에서 사용될 목적으로 선언
     */
    private static class InnerInstanceClazz() {
        // 클래스 로딩 시점에서 생성
        private static final Singleton uniqueInstance = new Singleton();
    }

    public static Singleton getInstance() {
        return InnerInstanceClazz.instance;
    }
    
}
```

- InnerInstanceClazz 클래스의 변수가 없기 때문에, static 멤버 클래스라도, 클래스 로더가 초기화 과정을 진행할 때 
  - InnerInstanceClazz 메서드를 초기화 하지 않고
  - getInstance() 메서드를 호출할 때 초기화된다.
- 즉, 동적 바인딩(dynamic Binding) (런타임 시, 성격 결정)의 특징을 이용하여 Thread-safe하면서 성능이 뛰어나다.



- InnerInstaceClazz 내부 인스턴스는 static이기 때문에 클래스 로딩 시점에 한번만 호출된다는 점을 이용한 것이며, final을 써서 다시 값이 할당되지 않도록 한다.





참조)

https://velog.io/@pond1029/JVM



# :star: 2. Entity vs DTO vs VO

### Entity란?

- 실제 DB의 테이블과 1:1 매핑되는 클래스
- DB의 테이블 내에 존재하는 컬럼만을 속성으로 갖는다.
- Entity 클래스는 상속 x, 구현체 x, 테이블 내에 존재하지 않는 컬럼 x



### DTO(Data Transfer Object)란?

- 데이터 전송(이동) 객체라는 의미
- 주로 비동기 처리할 때 사용
- 계층간 데이터 교환을 위한 객체(Java Bean)이다.
- DB의 데이터를 Service나 Controller 등으로 보낼 때 사용하는 객체를 의미한다.
- 즉, DB의 데이터가 Presentation Logic Tire로 넘어올떄는 DTO로 변환되어 오고가는 것이다.



### VO(Value Object)는?

- DTO와 동일한 개념이지만 read only 속성
- VO는 특정한 비즈니스 값을 담는 객체이고,
- DTO는 Layer 간의 통신 용도로 오고가는 객체를 말한다.



### Entity vs DTO 분리 이유

- DB Layer와 View Layer 사이의 역할을 분리하기 위해서이다.
- Entity 클래스
  - 실제 테이블과 매핑되어 만일 변경되면 여러 다른 클래스에 영향을 끼친다.
- DTO 클래스
  - View와 통신하며 자주 변경되므로 분리 해주어야 한다.
