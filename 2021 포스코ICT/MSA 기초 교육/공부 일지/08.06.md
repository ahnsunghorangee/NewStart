# 직렬화(Serialization)

- 자바 시스템 내부에서 사용되는 Object 또는 Daa를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형ㅌ로 데이터를 변환하는 기술
- JVM의 메모리에 상주되어 있는 객체 데이터를 바이트 형태로 변환하는 기술이다.
- 다차원의 자료를 파일로 저장하거나 네트워크로 보내기에 알맞게 일차원으로 펼치고 다시 원래대로 되돌리는 것을 직렬화라고 한다.
- 역직렬화는 반대로 바이트 -> data, object로 변환



#### 직렬화 종류

- 직렬화되는 자료가 어떤 종류인지를 나타내는 데이터 모델이 있고, 이 데이터 모델이 언제 결정되느냐에 따라 2종류로 나눈다.

1. schematic
   - 데이터 모델이 고정되어 있어서 나중에 별로 바뀌지 않는다는 걸 알고 직렬화 포맷을 데이터 모델마다 생성해서 쓸 수 있다.
2. schmaless
   - 대부분의 데이터 모델을 포함하는 범용 데이터 모델을 쓰는 접근이다.
   - 재귀가 없고 순서가 있는 순열 및 순서가 없는 집합만 가지고 있는 것들로 JSON이나 Message Pack 같은 것들에 해당한다.
   - XML이 DTD나 XML Schema 같은 것과 결합해서 스키마가 존재하게 되면 schematic하고 그렇지 않으면 schemaless하다고 할 수 있다.



#### 자바에서의 직렬화

- 개발에 최적화되어 있기 때문에 복잡한 데이터 구조의 클래스의 객체라도 직렬화 기본 조건만 지키면 큰 작업없이 바로 직렬화를 사용할 수 있다.
- JVM 메모리에서만 상주되어 있는 객체 데이터를 그대로 영속화가 필요할 때 사용된다.
- 이러한 장점 때문에 네트워크 전송도 가능하고 필요할 때 직렬화된 객체 데이터를 가져와서 역직렬화하여 객체를 바로 사용할 수 있게 해준다.



``` java
public class MemberVo implements Serializable{

        private static final long serialVersionUID = 2868210232929931052L;
        private String name;
        private int age;
    }
```

- java.io.Serializable 인터페이스를 보면 구현해야 하는 메서드가 없다.
- 이유는? Serializable 인터페이스를 구현한 구현체가 직렬화 대상이다라는 것을 JVM에게 알려주는 역할만 하기 때문
- serialVersionUID가 필요한 이유는?
  - 직렬화 과정에서 serialVersionUID의 버전이 포함되게 되고
  - 역직렬화 과정에서 Java class에 선언되어 있는 serialVersionUID의 버전과 서로 동일한지 체크 해준다.



# 자바 컴파일, 실행 순서

<center>
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlBHFV%2FbtqSGinqYMI%2FBt5L1jXsnUvf1UDUWgx3L1%2Fimg.png"/>
</center>

1. javac로 hello.java를 컴파일하면 자바 컴파일러가 컴파일하여 자바 클래스 파일(바이트 코드)로 만든다.
2. 그러면 java.class 클래스 파일 생성
3. 새로 생긴 java.class를 Java 프로그램 명렬어를 통해 실행한다.
   - 이 실행되는 순간 JVM이 동작한다.
4. 클래스 로더가 클래스(바이트 코드)를 JVM내의 Runtime Data Areas로 올린다.
5. 클래스 로더가 Runtime Data Areas로 클래스를 올리면 이 올라간 클래스 파일(바이트 코드)은 Execution Engine(JIT 컴파일러/인터프리터)에 의해 실행된다.