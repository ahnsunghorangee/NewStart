# 타입스크립트 인터페이스

기존 자바스크립트에는 인터페이스 개념이 없었다.

인터페이스란 두 개의 시스템 사이에 상호작용할 수 있게 해주는 조건, 규약이다.



#### 인터페이스 사용

```typescript
// TS
function createKeyboard(orderSheet: { ingredient: string, keyCount: number }) {
    console.log(`키보드 만드는중...`);
}
let orderSheet = {
    ingredient: 'plastic',
    keyCount: 40,
};
createKeyboard(orderSheet);
```

위처럼 함수 형태로 입력을 받으면, 양이 방대할 경우 복잡해진다.

```typescript
// TS
interface OrderSheet {
    ingredient: string;
    keyCount: number;
}
function createKeyboard(orderSheet: OrderSheet) {
    console.log(`키보드 만드는중...`);
}
```

인터페이스를 사용하면 확실히 **가독성**이 더 좋아진다.



#### 선택적 프로퍼티

선택적으로 어떠한 옵션을 주어야할 때 선택적 프로퍼티를 이용한다. **이름의 끝에 ?**만 넣어주면 된다.

```typescript
// TS
interface OrderSheet {
    ingredient: string;
    keyCount: number;
    name?: string;
}
function createKeyboard(orderSheet: OrderSheet) {
    console.log(`키보드 만드는중...`);
}
let orderSheet1 = {
    ingredient: 'plastic',
    keyCount: 40,
};
let orderSheet2 = {
    ingredient: 'metal',
    keyCount: 30,
    name: 'heecheolman',
};
createKeyboard(orderSheet1);
createKeyboard(orderSheet2);
```



#### 읽기전용 프로퍼티

수정할 수 없는 시스템일 경우 읽기전용으로 하고 싶은 프로퍼티 앞에 **readonly**만 붙여주면 된다.

```typescript
// TS
interface OrderSheet {
    ingredient: string;
    keyCount: number;
    readonly name?: string;
}
function createKeyboard(orderSheet: OrderSheet) {
    console.log(`키보드 만드는중...`);
    // orderSheet.name = 'heecheol';
    // Error : TS2540: Cannot assign to 'name' because it is a read-only property.
}
```

readonly는 const와 동일한 역할을 수행한다. 변수일 경우엔 const를 사용하고 프로퍼티일 경우에는 readonly를 사용하면 된다.



#### 함수 타입

인터페이스의 프로퍼티로 함수 시그니처를 정의할 수 있다.



시그니처(signature)란?

- 파라미터와 그들의 타입
- 반환값과 타입
- 던져지거나 콜백으로 반환되는 exceptions
- OOP에서 메서드 접근 권한에 대한 정보(public, static, 혹은 prototype과 같은 키워드들)

```typescript
// TS
interface TypingSpec {
    (sound: string, weight: number): boolean;
}
const checkCreatedKeyboard: TypingSpec = (s: string, w: number): boolean => w < 10;
console.log(checkCreatedKeyboard('took', 11)); // false;
console.log(checkCreatedKeyboard('tok', 3)); // true
```

> 만약 w가 10이상이면 false값을 리턴한다.



#### Indexable 타입

```typescript
interface StringArray {
    [index: number]: string;
}
let myArray: StringArray;
myArray = ['bob', 'fred'];
let myStr: string = myArray[0];
console.log(myStr); // bob
```

StringArray가 number로 인덱스 될 때 string을 리턴합니다.



#### 클래스 타입

클래스에서 implements 키워드를 통해 인터페이스를 사용할 수 있다.

```typescript
// TS
interface ClockInterface {
    currentTime: Date;
}
class Clock implements ClockInterface {
    public currentTime: Date;
    // private _currentTime: Date; // Error!
}
const digital: ClockInterface = new Clock();
```

인터페이스를 구현하는 클래스는 public만을 사용할 수 있는데 그 이유는 private로 구현을 하면 인터페이스를 구현했는지 안했는지 모르기 때문이다.

추가적으로 인터페이스를 구현한 클래스의 타입은 인터페이스가 될 수 있다.



#### 확장 인터페이스

인터페이스도 클래스처럼 extends 키워드를 통해 확장할 수 있다. 인터페이스를 분리함으로써 재사용성이 뛰어나게 된다.

```tsx
// TS
interface DOM {
    display: string;
    tag: string;
}

interface TextNode extends DOM {
    text: string;
}

interface InputNode extends DOM {
    type: string;
}

const textNode: TextNode = {
    display: 'inline',
    tag: 'text',
    text: 'heecheolman',
};

const InputNode: InputNode = {
    display: 'inline-block',
    tag: 'input',
    type: 'button',
};
```