# ES6 문법 정리

이전에는 jQuery를 활용한 ES5문법으로 JS 코드를 작성하였지만, 이제는 ES6문법으로 JS 코드를 작성한다.



## ES6(ECMAScript6)의 새로운 기능은?

- const / let
- Arrow Function(화살표 함수)
- Template Literals(탬플릿 리터럴)
- Default parameters(기본 매개변수)
- Array and object destruction(배열 및 객체 비구조화)
- Promise(프로미스)
- Rest parameter and Spread operator(나머지 매개변수 및 확산 연산자)
- Classes(클래스)



#### 1. const and let

const는 변수 선언을 위한 새로운 키워드

var보다 강력하고 일단 사용되면 변수를 다시 할당할 수 없다.

즉, 객체와 함께 사용할 때를 제외하고는 변경 불가능한 변수

```js
// ES5
var MyBtn = document.getElementById('mybtn');

// ES6
const MyBtn = document.getElementById('mybtn');
```

위의 코드에서 const는 변경되지 않으며 재할당할 수 없다. 새로운 값을 제공하려고 하면 오류가 반환된다.



let은 새로운 값을 가질 수도 있고 재할당할 수도 있다.

```js
let name = '철수';

name = '영희';

console.log(name); // 출력 => 영희
```



#### 2. Arrow Functions

```js
// ES5
function myFunc(name) {
	return '안녕' + name;
}

console.log(myFunc('영희'));
```

```js
// ES6 화살표 함수
const myFunc = (name) => {
	return `안녕 ${name}`;
}

console.log(myFunc('영희')); // 출력 => 안녕 영희

// 또는 화살표를 사용하거나 'return' 키워드를 사용하지 않아도 됩니다
const myFunc = (name) => `안녕 ${name}`;

console.log(myFunc('영희')); // 출력 => 안녕 영희
```



화살표 함수를 map과 filter, reduce 등 내장 함수와 함께 사용할 수도 있다.

```js
// ES5
const myArrary = ['진수', '영철', '영희', 5];

let arr1 = myArrary.map(function(item) {
	return item;
});

console.log(arr1); // 출력 => (4) ["진수", "영철", "영희", 5]

// ES6
let arr2 = myArrary.map((item) => item);

console.log(arr2); // 출력 => (4) ["진수", "영철", "영희", 5]
```



#### 3. Template Literals

문자열을 연결하기 위해 더하기(+) 연산자를 사용할 필요는 없으며, 백틱(`)을 사용하여 문자열 내에서 변수를 사용할 수 있다.

```js
// ES5
function myFunc1() {
	return '안녕' + name + '너의 나이는' + age + '살 이다!'; 
}

console.log(myFunc1('영희', 22));
// 출력 => 안녕 영희 너의 나이는 22살 이다!
```

```js
// ES6
const myFunc = (name, age) => {
	return `안녕 ${name}, 너의 나이는 ${age}살 이다!`; 
};

console.log(myFunc1('영희', 22));
// 출력 => 안녕 영희, 너의 나이는 22살 이다!
```



#### 4. Default parameters

매개변수를 쓰지 않은 경우, 매개 변수가 이미 기본값에 정의되어 있으므로 정의되지 않은 오류가 반환되지 않는다. 따라서 누락된 매개변수를 사용하여 함수를 실행할 때 기본 매개 변수 값을 사용하고 오류를 반환하지 않는다.

```js
const myFunc = (name, age) => {
	return `안녕 ${name} 너의 나이는 ${age}살 이니?`; 
};

console.log(myFunc1('영희'));
// 출력 => 안녕 영희 너의 나이는 undefined살 이니?
```

```js
const myFunc = (name, age = 22) => {
	return `안녕 ${name} 너의 나이는 ${age}살 이니?`; 
};

console.log(myFunc1('영희'));
// 출력 => 안녕 영희 너의 나이는 22살 이니?
```

두번째 매개변수를 놓쳤더라도 값을 반환한다.



#### 5. Array and object destructing

비구조화를 통해 배열 또는 객체의 값을 새 변수에 더 쉽게 할당할 수 있다.

```js
// ES5 문법
const contacts = {
	famillyName: '이',
	name: '영희',
	age: 22
};

let famillyName = contacts.famillyName;
let name = contacts.name;
let myAge = contacts.age;

console.log(famillyName);
console.log(name);
console.log(age);
// 출력
// 이
// 영희
// 22
```

```js
// ES6 문법
const contacts = {
	famillyName: '이',
	name: '영희',
	age: 22
};

let { famillyName, name, age } = contacts;

console.log(famillyName);
console.log(name);
console.log(age);
// 출력
// 이
// 영희
// 22
```

※ 속성이름과 동일하지 않은 변수를 할당하면 undefined가 반환된다. 그러나 변수의 이름을 바꾸려면 콜른을 사용하면 된다.

```js
// ES6 문법
const contacts = {
	famillyName: '이',
	name: '영희',
	age: 22
};

let { famillyName, name: anotherName, age } = contacts;

console.log(ontherName);
// 영희
```

배열의 경우 객체와 동일한 구문을 사용한다.

```js
const arr = ['광희', '지수', '영철', 20];

let [value1, value2, value3] = arr;

console.log(value1);
console.log(value2);
console.log(value3);
// 출력
// 광희
// 지수
// 영철
```



#### 6. Promise

비동기 코드를 쓰는 방법이다

```js
const myPromise = () => {
	return new Promise((resolve, reject) => {
		resolve('안녕하세요 Promise가 성공적으로 실행했습니다');
	});
};

cosole.log(myPromise()); // Promise {<resolved>: "안녕하세요 Promise가 성공적으로 실행했습니다"}
```

데이터를 가져온 후 함수를 실행하려면 Promise를 사용한다.

```js
const url = 'https://jsonplaceholder.typicode.com/posts';
const getData = (url) => {
	return fetch(url);
};

getData(url).then(data => data.json()).then(result => console.log(result));
```

fetch 함수는 Promise 자체를 반환한다.



#### 7. Rest parameter and Spread operator

Rest parameter는 배열의 인수를 가져오고 새 배열을 반환하는데 사용된다.

```js
const arr = ['영희', 20, '열성적인 자바스크립트', '안녕', '지수', '어떻게 지내니?'];

// 비구조화를 이용한 값을 얻기
const [ val1, val2, val3, ...rest ] = arr;

const Func = (restOfArr) => {
	return restOfArr.filter((item) => {return item}).join(" ");
};

console.log(Func(rest)); // 안녕 지수 어떻게 지내니?
```



Spread operator는 Rest parameter와 구문이 동일하지만 Spread operator는 인수뿐만 아니라 배열 자체를 가진다. for 반복문이나 다른 메서드를 사용하는 대신 Spread operator를 사용하여 배열의 값을 가져올 수 있다.

```js
const arr = ['영희', 20, '열성적인 자바스크립트', '안녕', '지수', '어떻게 지내니?'];

const Func = (...anArray) => {
	return anArray;
};

console.log(Func(arr));
// 출력 => ["영희", 20, "열성적인 자바스크립트", "안녕", "지수", "어떻게 지내니?"]
```



#### 8. Classes

class는 객체 지향 프로그래밍의 핵심이다. 코드를 더욱 안전하게 캡슐화할 수 있다. class를 사용하면 코드 구조가 좋아지고 방향을 유지한다.

