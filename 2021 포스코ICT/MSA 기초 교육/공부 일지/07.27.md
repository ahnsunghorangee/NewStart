# 상속

기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

- 재사용성 향상
- 코드 중복 제거
- extends



### 특징)

- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다



# 다형성

조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조한다.



``` java
class Tv{
    
}
class CaptionTv extends Tv {
    
}
```



CaptionTv c = new CaptionTv();

Tv t = new CaptionTv();

에서 c는 CaptionTv와 Tv의 모든 멤버를 사용할 수 있지만,

t는 Tv 오직 Tv 멤버만 사용 가능하고, CaptionTv 멤버는 사용불가하다.

- CaptionTv c = new Tv();와 같이 자손 타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 불가능

- 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다.

- 참조변수 c = new 인스턴스();



## 참조변수의 형변환

자손 타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로 형변환 가능하다.

- 자손 타입 -> 조상 타입(Up-casting): 형변환 생략 가능
- 조상 타입 -> 자손 타입(Down-casting): 형변환 생략 불가능

``` java
class Cas{}
class FireEngine extends Car{}
class Ambulance extends Car{}

Car car = null;
FireEngine fe = new FireEngine();
FireEngine fe2 = null;

car = fe; // car = (Car)fe; Up-casting 생략가능
fe2 = (FireEngine) car; // 형변환 생략불가, Down-casting
```

Down-casting은 멤버의 개수를 늘리는 작업이여서 문제 발생 가능성이 있다.

그래서 instatnceof 연산자를 사용해서, 참조변수가 참조하고 있는 실제 인스턴스의 타입을 확인하는 것이 안전하다.



### instanceof 연산자

- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용한다.

- 실제 인스턴스와 같은 타입의 instanceof 연산 이외에 조상 타입의 instanceof 연산에도 true를 결과로 얻으며, instanceof 연산의 결과가 true라는 것은 검사한 타입으로의 형변환을 해도 아무런 문제가 없다는 뜻이다.
- 참조변수.getClass().getName() 참조변수가 가리키는 인스턴스 클래스 이름 반환



# Map

## 1) HashMap

- 내부적으로 Entry 배열을 만들어 관리, map.put() 로 엔트리를 추가하면 Key값으로 넘겨준 객체의 해시 코드를 계산하여 Entry 배열의 접근 인덱스로 사용한다.
- 순서를 보장하지 않는다.



## 2) TreeMap

- key-value 쌍을 내부적으로 RedBlack Tree로 저장하여 관리
- Key 값을 기준으로 정렬된 상태를 유지
- Comparator 인터페이스를 구현하면 사용자가 정렬 순서를 조정 가능
- HashMap보다 느리다.



## 3) LinkedHashMap

- 데이터의 입력된 순서를 기억

- 저장되는 각 항목은 Map.Entry 클래스를 구현한 Node 클래스로 내부에 before, after 멤버를 갖는 연결리스트 구조를 가지고 있다.