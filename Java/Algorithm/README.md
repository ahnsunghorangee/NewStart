# Algorithm



## 1. Recursive

재귀: 자신의 메소드 내부에서 자신의 메소드를 순환적 호출

1) 기저조건: 재귀 탈출

2) 재귀깊이

3) 수행시간

※ Memoization: 기존 수행 결과 저장, 이로 인해 추가적인 메모리 공간 필요(적절한 자료구조 사용)

## 2. Permutation

**순열**: 서로 다른 n개의 수 중 r개를 선택하여 나열

nPr = n x (n-1) x (n-2) x ... x (n-r+1)

​	1) 고정값 o => for문

​	2) 고정값 x => 재귀

​			각 자기에서 앞쪽에 선택된 수를 배제하고 가능한 모든 수를 선택

​			앞쪽에서 선택된 수: boolean배열 || Bit masking



​		(1) Bit masking

​			1<<a: 1비트를 오른쪽에서 a위치에 올 수 있도록

​			ex) 1<<0: _ _ _ 1

​			ex) 1<<1: _ _ 1 _

​			ex) 1<<2: _ 1 _ _



**중복순열**: 서로 다른 n개의 수 중 중복하여 r개를 선택하여 나열

n^r = _ _ _ _ => 각 칸에 1~9 / 1~9 / 1~9 / 1~9



**next permutation**: 현재 순열의 상태에서 크기 순으로(사전순) 다음에 올 수 있는 순열

1,3,5 => 135 -> 153 -> 315 -> 351 -> 513 -> 531

1) 시작 순열 상태가 만들 수 있는 가장 작은 순열부터 시작
	2) 사용 후 np() 호출 (do-while문)
	

	사용용도: 1 3 5 4 2에서 1 4 2 3 5 찾기
	1) 뒤쪽부터 탐색하며 꼭대기(i) 찾는 작업
		=>	i-1: 교환자리
			i == 0: 가장 큰 순열 => 다음 순열 생성 x
			i != 0: 직전 자리가 교환할 자리, 꺾어지는 부분을 찾는다.
	
			5(꼭대기, i)
		3(i-1)	4
	1				2
		
	2) i-1위치에 교환할 큰 값(j) 찾기
	3) i-1 위치, j위치 값 교환
			5(꼭대기, i)
		4		3
	1				2
	
	4) i~맨 뒤 교환하며 오름차순으로 정렬
		5			2
			3			3
				2를 			5로 만든다.

## 3. Combination

**중복순열**: 주사위를 N번 던져서 나올 수 있는 모든 경우 (6Pi3 = 216)

ex) 111, 112, ..., 121, ... 666

**순열**: 주사위를 N번 던져서 모두 다른 수가 나올 수 있는 모든 경우 (6P3 = 120)

ex) 123, 124, ..., 132, ..., 654



**중복조합**: 주사위를 N번 던져서 중복이 되는 경우를 제외하고 나올 수 있는 모든 경우(112,121,211 중복) (6H3 = 6+3-1C3 = 56)

ex) 111, 112, 113, 114, 115, 116, 122, 123, 124, 125, 126, 133, 134, ..., 144, ..., 166, 222

**조합**: 주사위를 N번 던져서 모두 다른 수가 나올 수 있는 모든 경우 (6C3 = 20)

ex) 123, 124, 125, 126, 134, 135, ..., 456



### ※ 정리 ※

| -            | 순서 | 중복 |
| ------------ | ---- | ---- |
| 중복순열(Pi) | O    | O    |
| 순열(P)      | O    | X    |
| 중복조합(H)  | X    | O    |
| 조합(C)      | X    | X    |





test test